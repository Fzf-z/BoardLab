"use strict";const i=require("worker_threads"),Y=require("better-sqlite3");if(!i.parentPort)throw new Error("This file must be run as a worker thread.");const e=new Y(i.workerData.dbPath);e.pragma("foreign_keys = ON");console.log(`Worker: Database initialized at ${i.workerData.dbPath}`);e.exec(`
  CREATE TABLE IF NOT EXISTS projects (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    board_type TEXT,
    board_model TEXT,
    attributes TEXT,
    notes TEXT,
    image_data BLOB,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  );
`);try{e.prepare("PRAGMA table_info(projects)").all().some(d=>d.name==="notes")||(e.exec("ALTER TABLE projects ADD COLUMN notes TEXT"),console.log("Worker: Migrated projects table to include 'notes' column."))}catch(p){console.error("Worker: Error migrating projects table:",p)}e.exec(`
  CREATE TABLE IF NOT EXISTS points (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER,
    x REAL NOT NULL,
    y REAL NOT NULL,
    label TEXT,
    notes TEXT,
    type TEXT,
    category TEXT,
    tolerance REAL,
    expected_value TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (project_id) REFERENCES projects (id)
  );
`);try{const p=e.prepare("PRAGMA table_info(points)").all(),E=p.some(r=>r.name==="tolerance"),d=p.some(r=>r.name==="category");E||(e.exec("ALTER TABLE points ADD COLUMN tolerance REAL"),e.exec("ALTER TABLE points ADD COLUMN expected_value TEXT"),console.log("Worker: Migrated points table to include 'tolerance' and 'expected_value' columns.")),d||(e.exec("ALTER TABLE points ADD COLUMN category TEXT"),console.log("Worker: Migrated points table to include 'category' column."))}catch(p){console.error("Worker: Error migrating points table:",p)}e.exec(`
  CREATE TABLE IF NOT EXISTS measurements (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    point_id INTEGER,
    type TEXT NOT NULL,
    value TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (point_id) REFERENCES points (id)
  );
`);console.log("Worker: Database schema ensured.");async function G(p){var m,b,y;const{id:E,type:d,payload:r}=p;try{let n;switch(d){case"db:get-projects":n=e.prepare("SELECT id, board_type, board_model, attributes, notes, created_at FROM projects ORDER BY created_at DESC").all().map(s=>({...s,attributes:JSON.parse(s.attributes||"{}")}));break;case"db:get-project-with-image":const l=e.prepare("SELECT * FROM projects WHERE id = ?").get(r);l&&(l.attributes=JSON.parse(l.attributes||"{}")),n=l;break;case"db:create-project":const{board_type:S,board_model:I,attributes:D,image_data:j,notes:C}=r,_=Buffer.from(j);n={id:e.prepare("INSERT INTO projects (board_type, board_model, attributes, image_data, notes) VALUES (?, ?, ?, ?, ?)").run(S,I,JSON.stringify(D),_,C||"").lastInsertRowid,...r,image_data:_};break;case"db:get-all-attributes":const g=r==null?void 0:r.boardType;let u;g?u=e.prepare("SELECT attributes FROM projects WHERE attributes IS NOT NULL AND board_type = ?").all(g):u=e.prepare("SELECT attributes FROM projects WHERE attributes IS NOT NULL").all();const f=new Set,A=new Set;for(const s of u)try{const t=JSON.parse(s.attributes);for(const a in t)f.add(a),typeof t[a]=="string"&&t[a].trim()!==""&&A.add(t[a])}catch{}n={keys:[...f].sort(),values:[...A].sort()};break;case"db:save-points":const{projectId:N,points:k}=r,w=e.prepare("INSERT INTO points (project_id, x, y, label, notes, type, category, tolerance, expected_value) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"),h=e.prepare("UPDATE points SET x = ?, y = ?, label = ?, notes = ?, type = ?, category = ?, tolerance = ?, expected_value = ? WHERE id = ?"),T=[];e.transaction(s=>{for(const t of s)if(typeof t.id=="string"&&t.id.startsWith("temp-")){const a=w.run(N,t.x,t.y,t.label,t.notes||"",t.type||"voltage",t.category||null,t.tolerance||null,t.expected_value||null),o=e.prepare("SELECT * FROM points WHERE id = ?").get(a.lastInsertRowid);o&&(o.temp_id=t.id,T.push(o))}else if(typeof t.id=="number"){h.run(t.x,t.y,t.label,t.notes||"",t.type||"voltage",t.category||null,t.tolerance||null,t.expected_value||null,t.id);const a=e.prepare("SELECT * FROM points WHERE id = ?").get(t.id);a&&T.push(a)}})(k);const F=e.prepare("SELECT * FROM points WHERE project_id = ?").all(N),P=e.prepare("SELECT * FROM measurements WHERE point_id = ? ORDER BY created_at DESC");n=F.map(s=>{const t=P.all(s.id),a={};for(const c of t)if(!a[c.type])try{const R=JSON.parse(c.value);c.type==="oscilloscope"?a[c.type]={...R,capturedAt:c.created_at}:a[c.type]={type:c.type,value:R,capturedAt:c.created_at}}catch{a[c.type]={type:c.type,value:c.value,capturedAt:c.created_at}}const o=T.find(c=>c.id===s.id);return{...s,measurements:a,temp_id:o==null?void 0:o.temp_id}});break;case"db:get-points":const W=e.prepare("SELECT * FROM points WHERE project_id = ?").all(r),v=e.prepare("SELECT * FROM measurements WHERE point_id = ? ORDER BY created_at DESC");n=W.map(s=>{const t=v.all(s.id),a={};for(const o of t)if(!a[o.type])try{const c=JSON.parse(o.value);o.type==="oscilloscope"?a[o.type]={...c,capturedAt:o.created_at}:a[o.type]={type:o.type,value:c,capturedAt:o.created_at}}catch{a[o.type]={type:o.type,value:o.value,capturedAt:o.created_at}}return{...s,measurements:a}});break;case"db:save-measurement":case"db:createMeasurement":const{pointId:L,type:M,value:U}=r||{};if(!L||!M)throw new Error("Invalid payload: pointId and type are required");n={id:e.prepare("INSERT INTO measurements (point_id, type, value) VALUES (?, ?, ?)").run(L,M,JSON.stringify(U)).lastInsertRowid};break;case"db:getMeasurementsForPoint":r?n=e.prepare("SELECT * FROM measurements WHERE point_id = ? ORDER BY created_at DESC").all(r):n=[];break;case"db:delete-project":if(!r)throw new Error("projectId required");e.transaction(s=>{e.prepare("DELETE FROM measurements WHERE point_id IN (SELECT id FROM points WHERE project_id = ?)").run(s),e.prepare("DELETE FROM points WHERE project_id = ?").run(s),e.prepare("DELETE FROM projects WHERE id = ?").run(s)})(r),n={status:"success"};break;case"db:delete-point":if(!r)throw new Error("Point ID is required");e.transaction(s=>(e.prepare("DELETE FROM measurements WHERE point_id = ?").run(s),e.prepare("DELETE FROM points WHERE id = ?").run(s)))(r).changes>0?n={status:"success"}:n={status:"error",message:"Point not found or not deleted"};break;case"db:update-project":const{id:O,board_model:x,board_type:B,attributes:H,notes:X}=r;if(!O)throw new Error("Project ID required");e.prepare("UPDATE projects SET board_model = ?, board_type = ?, attributes = ?, notes = ? WHERE id = ?").run(x,B,JSON.stringify(H),X||"",O).changes>0?n={status:"success",...r}:n={status:"error",message:"Project not found or no changes made"};break;case"close":console.log("Worker: Compacting database before closing..."),e.exec("VACUUM"),e.close(),console.log("Worker: Database connection closed."),(m=i.parentPort)==null||m.postMessage({id:E,result:{status:"closed"}}),process.exit(0);break;default:throw new Error(`Unknown database operation: ${d}`)}(b=i.parentPort)==null||b.postMessage({id:E,result:n})}catch(n){(y=i.parentPort)==null||y.postMessage({id:E,error:{message:n.message,stack:n.stack}})}}i.parentPort.on("message",G);
